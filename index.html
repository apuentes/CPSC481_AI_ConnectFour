<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
    <!--<script src="./phaser.min.js"></script>-->
</head>
<body>

    <script>
    var config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 200 }
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    var pPieces = [];
    var aiPieces = [];
                /* Column X Coords
            242-262  Col 1
            296-313  Col 2
            349-366  Col 3
            405-415  Col 4
            457-470  Col 5
            507-521  Col 6
            560-576  Col 7

            */
    var pieceColLoc = [242,296,349,400,452,505,558];
    var pieceRowLoc = [430,373,320,263,208,153];
    var board = [[0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0]];
    var pPieceCol = 0;
    var player = 1;
    var keyReleased;
    var addPiece;
    var game = new Phaser.Game(config);


    function preload ()
    {

        this.load.image('board', 'assets/c4Board.png');
        this.load.image('red', 'assets/redPiece.png');
        this.load.image('yellow', 'assets/yellPiece.png');

    }

    function create ()
    {
        this.left = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.LEFT);
        this.right = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.RIGHT);
        this.enter = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ENTER);


        //create game pieces
        for (let i=0; i<42; i++)
        {
            pPieces.push(this.add.sprite(242,-50, 'red').setScale(.5));
            aiPieces.push(this.add.sprite(242,-50, 'yellow').setScale(.5));
        }

        this.pPosPiece = this.add.sprite(242, 528, 'red').setScale(.5);
        
        var pointer = this.input.activePointer;
        var gameBoard = this.add.image(400, 300, 'board');
        gameBoard.setScale(1.5);
        console.log(game.input.x+" "+game.input.y);
        this.posY = 0;
        this.text = this.add.text(242, 15, " ", {
        font: "25px Arial",
        fill: "#ff0044",
        align: "center"
        });

    }

    function clearBoard()
    {
        //TODO create a clear board function that pours the pieces down the bottom
        // and bounce out of scene

    }

    //TODO pass in player
    function evalFunction(curPlayer)
    {
        //Check for horizontal winner
        let consec = 0;
        let maxConsec = 0;
        for (let row=0; row<=5; row++)
        {
            for (let col=0; col<=6; col++)
            {
                if (board[row][col]==curPlayer)
                {
                    consec = consec +1;
                    if (consec==4)
                    {
                        console.log("horizontal winner at: "+row,col);
                        return true;
                    }
                }
                else if(board[row][col]==0 || board[row][col]==-curPlayer)
                {
                    if (consec < maxConsec)
                    {
                        maxConsec = consec;
                    }
                    consec = 0;
                }
            }
 
        }
        //Check for vertical winner
        consec = 0;
        for (let col=0; col<=6; col++)
        {
            for (let row=0; row<=5; row++)
            {
                if (board[row][col]==curPlayer)
                {
                    consec = consec+1;
                    if (consec==4)
                    {
                        console.log("vertical winner at: "+row,col);
                        return true;
                    }
                }
                else
                {
                    if (consec < maxConsec)
                        {
                            maxConsec = consec;
                        }
                    consec = 0;
                }
            }
        }
        //Check positive slope winner
        for (let row=0; row<3; row++)
        {
            for (let col=0; col<4; col++)
            {
                if (board[row][col]==curPlayer && board[row+1][col+1]==curPlayer && board[row+2][col+2]==curPlayer && board[row+3][col+3]==curPlayer)
                {
                    console.log("positive slope winner at: "+row+3,col+3);
                    return true;
                }
            }
         }
        //Check negative slope winner
        for (let row=5; row>2; row--)
        {
            for (let col=0; col<4; col++)
            {
                if (board[row][col]==curPlayer && board[row-1][col+1]==curPlayer && board[row-2][col+2]==curPlayer && board[row-3][col+3]==curPlayer)
                {
                    console.log("negative slope winner at: "+row-3,col+3);
                    return true;
                }
            }
         }
        //player = -player;
        return false;

    }

    function updateBoard(board, player, col){
        let b=structuredClone(board);
        //console.log(col);
        if (player)
        {
            for (let row=0; row<=5; row++)
                {
                    if (b[row][col] == 0)
                    {
                        //rowIndex = pieceRowLoc[row];
                        rowIndex = row;
                        b[row][col] = player;
                        break;
                    }
                }
        }
        return {b,rowIndex};
    }

    function getRandInt(min, max)
    {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min) + min);
    }

    function aiEvalCheck(brd, curPlayer)
    {
        let consec = 0;
        let maxConsec = 0;
        let xCoord = 0;
        let yCoord = 0;
        b = structuredClone(brd);

        for (let row=0; row<=5; row++)
        {
            for (let col=0; col<=6; col++)
            {
                if (b[row][col]==curPlayer)
                {
                    consec = consec +1;
                    if (consec==4)
                    {
                        return true;
                    }
                }
                else if(b[row][col]==0)
                {
                    if (consec > maxConsec)
                    {
                        maxConsec = consec;
                        xCoord = col;
                        yCoord = row
                    }
                    consec = 0;
                }
                else
                {
                    consec =0;
                }
            }
 
        }
        //Check for vertical winner
        consec = 0;
        for (let col=0; col<=6; col++)
        {
            for (let row=0; row<=5; row++)
            {
                if (b[row][col]==curPlayer)
                {
                    consec = consec+1;
                    if (consec==4)
                    {
                        return true;
                    }
                }
                else if (b[row][col]==0)
                {
                    if (consec > maxConsec)
                        {
                            maxConsec = consec;
                            xCoord = col;
                            yCoord = row;
                        }
                    consec = 0;
                }
                else
                {
                    consec=0;
                }
            }
        }
        
                //Check positive slope winner
        for (let row=0; row<3; row++)
        {
            for (let col=0; col<4; col++)
            {
                if (b[row][col]==curPlayer && b[row+1][col+1]==curPlayer && b[row+2][col+2]==curPlayer && b[row+3][col+3]==curPlayer)
                {
                    return true;
                }
                if (b[row][col]==curPlayer && b[row+1][col+1]==curPlayer && b[row+2][col+2]==curPlayer && b[row+3][col+3]==0)
                {
                    if (maxConsec < 3)
                    {
                        maxConsec = 3;
                        xCoord = col+3;
                        yCoord = row+3;
                    }
                }
                if (b[row][col]==curPlayer && b[row+1][col+1]==curPlayer && b[row+2][col+2]==0)
                {
                    if (maxConsec < 2)
                    {
                        maxConsec = 2;
                        xCoord = col+2;
                        yCoord = row+2;
                    }
                }
            }
         }
        //Check negative slope winner
        for (let row=5; row>2; row--)
        {
            for (let col=0; col<4; col++)
            {
                if (b[row][col]==curPlayer && b[row-1][col+1]==curPlayer && b[row-2][col+2]==curPlayer && b[row-3][col+3]==curPlayer)
                {
                    return true;
                }
                if (b[row][col]==curPlayer && b[row-1][col+1]==curPlayer && b[row-2][col+2]==curPlayer && b[row-3][col+3]==0)
                {
                    if (maxConsec < 3)
                    {
                        maxConsec = 3;
                        xCoord = col+3;
                        yCoord = row-3;
                    }
                }
                if (b[row][col]==curPlayer && b[row-1][col+1]==curPlayer && b[row-2][col+2]==0)
                {
                    if (maxConsec < 2)
                    {
                        maxConsec = 2;
                        xCoord = col+2;
                        yCoord = row-2;
                    }
                }
            }
         }
        return {xCoord, yCoord};
    }
        
    function boardFull(brd)
    {
        for (let i=0; i<7; i++)
        {
            if (brd[5][i]==0) return false;
        }
        return true;
    }
        
    function miniMax(brd, player, depth, alpha, beta)
    {
        if (evalFunction(brd, -1)) return [-1, 99999999];
        if (evalFunction(brd, 1)) return [-1, -99999999];
        if (boardFull(brd)) return [-1, 0];
        if (depth == 0) return [-1, 5];
        
        if (player == -1)
		{
			var value = Number.NEGATIVE_INFINITY;
			var col = -1;
			let piecePosition = aiEvalCheck(brd, player);
			let b = structuredClone(brd);
			b = updateBoard(b, player, piecePosition.xCoord).b;
			var nScore = miniMax(b, -player, depth -1, alpha, beta)[1];
			if (nScore > value)
			{
				value = nScore;
				col = piecePosition.xCoord;
			}
			alpha = Math.max(alpha, value);
			if (alpha >= beta) return;
			return [col, value];
		}
		else
		{
			var value = Number.POSITIVE_INFINITY;
			var col = -1;
			let piecePosition = aiEvalCheck(brd, player);
			let b = structuredClone(brd);
			b = updateBoard(b, player, piecePosition.xCoord).b;
			var nScore = miniMax(b, -player, depth -1, alpha, beta)[1];
			if (nScore < value)
			{
				value = nScore;
				col = piecePosition.xCoord;
			}
			beta = Math.min(alpha, value);
			if (alpha >= beta) return;
			return [col, value];
		}
		//return [col, value];
    }

    function aiPlayer(brd)
    {
        let col = getRandInt(0,7);
        //let boardVals = updateBoard(brd, -1, col);
        let v = miniMax(brd, -1, 3, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);
        console.log("value back from miniMax: "+v);
        let aiPosVal = aiEvalCheck(brd,-1);
        return {aiPosVal};
    }
 
    function update()
    {
        
        if (addPiece)
        {
            if (newPlayerPiece.y < row)
            {
                newPlayerPiece.y = newPlayerPiece.y +30;
            }
            else if (newPlayerPiece.y >= row)
            {

                if(evalFunction(player))
                {
                    console.log("Player "+player+"is the WIENER!!!!");
                    if (player == 1)
                    {
                        this.text.setText("YOU Win!");
                        player = 999;
                    }
                    else if (player == -1)
                    {
                        this.text.setText("YOU LOSE!");
                        player = 999;
                    }
                }
                else
                {
                    player = -player
                }
                console.log(board);
                addPiece = false;
            }
        }

        if (this.left.isDown)
        {
            if (this.keyReleased==true)
            {
                for (let i=0; i<=6; i++)
                {
                    if(this.pPosPiece.x == pieceColLoc[i] && i >0)
                    {
                        this.pPosPiece.x = pieceColLoc[i-1];
                        pPieceCol = i-1;
                        break;
                    }
                }
                this.keyReleased = false;
            }
        }
        else if (this.right.isDown)
        {
            if (this.keyReleased==true)
            {
                for (let i=0; i<6; i++){
                    if(this.pPosPiece.x == pieceColLoc[i] && i <6)
                    {
                        this.pPosPiece.x = pieceColLoc[i+1];
                        pPieceCol = i+1;
                        break;
                    }
                }
                this.keyReleased = false;
            }
        }
        else if (this.enter.isDown && player ==1)
        {
            
            if (this.keyReleased==true)
            {
//                for (let i=0; i<=5; i++)
//                {
//                    if (board[i][pPieceCol] == 0)
//                    {
//                        row = pieceRowLoc[i];
//                        board[i][pPieceCol] = player;
//                        break;
//                    }
//                }
                let vals=updateBoard(board, player, pPieceCol);
                board = vals.b;
                row = pieceRowLoc[vals.rowIndex];
                if (player==1)
                {
 
                    newPlayerPiece = pPieces.pop();
                }
                else if (player==-1)
                {

                    newPlayerPiece = aiPieces.pop();
                }
                newPlayerPiece.x = this.pPosPiece.x;

                addPiece = true;
            }
            this.keyReleased = false;
        }
        else if (this.left.isUp && 
                this.right.isUp && 
                this.enter.isUp &&
                !addPiece)
        {
            this.keyReleased = true;
        }

        if (player==-1 && addPiece==false)
        {
            let aiPosVals = aiPlayer(board);
            let bVals = updateBoard(board,player,aiPosVals.aiPosVal.xCoord);
            board = bVals.b;
            newPlayerPiece = aiPieces.pop();
            newPlayerPiece.x = pieceColLoc[aiPosVals.aiPosVal.xCoord];
            row = pieceRowLoc[bVals.rowIndex];
            addPiece = true;

        }

         
    }
    </script>
    <!--<script type="module" src="./phaser/dist/phaser.js" charset="utf-8"></script>-->
</body>
</html>
