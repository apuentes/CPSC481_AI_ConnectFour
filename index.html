<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
    <!--<script src="./phaser.min.js"></script>-->
</head>
<body>

    <script>
    var config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 200 }
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    var pPieces = [];
    var aiPieces = [];
    var aiBlockerPieces = [];
                /* Column X Coords
            242-262  Col 1
            296-313  Col 2
            349-366  Col 3
            405-415  Col 4
            457-470  Col 5
            507-521  Col 6
            560-576  Col 7
            */
    var pieceColLoc = [242,296,349,400,452,505,558];
    var pieceRowLoc = [428,372,320,263,208,150];
    var board = [[0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0]];
    var pPieceCol = 0;
    var player = 1;
    var keyReleased;
    var addPiece;
    var addBlockerPiece = false;
    var aiBlockerCnt = 0;
    var game = new Phaser.Game(config);


    function preload ()
    {

        this.load.image('board', 'assets/c4Board.png');
        this.load.image('red', 'assets/redPiece.png');
        this.load.image('yellow', 'assets/yellPiece.png');
        this.load.image('black', 'assets/blkPiece.png');

    }

    function create ()
    {
        this.left = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.LEFT);
        this.right = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.RIGHT);
        this.enter = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ENTER);


        //create game pieces
        for (let i=0; i<22; i++)
        {
            pPieces.push(this.add.sprite(242,-50, 'red').setScale(.5));
            aiPieces.push(this.add.sprite(242,-50, 'yellow').setScale(.5));
            aiBlockerPieces.push(this.add.sprite(242,-50, 'black').setScale(.5));
        }

        this.pPosPiece = this.add.sprite(242, 528, 'red').setScale(.5);
        
        var pointer = this.input.activePointer;
        var gameBoard = this.add.image(400, 300, 'board');
        gameBoard.setScale(1.5);
        this.posY = 0;
        this.text = this.add.text(242, 15, " ", {
        font: "25px Arial",
        fill: "#ff0044",
        align: "center"
        });

    }

    function clearBoard(board, plyr)
    {
        //TODO create a clear board function that pours the pieces down the bottom
        // and bounce out of scene
        var emptyBoard = new Array;
        for (var i=0; i < 6; i++)
        {
            emptyBoard.push(new Array(6).fill(0));
        }

    }

    //TODO pass in player
    function evalFunction(board, curPlayer)
    {
        //Check for horizontal winner
        let consec = 0;
        for (let row=0; row<=5; row++)
        {
            for (let col=0; col<=6; col++)
            {
                if (board[row][col]==curPlayer)
                {
                    consec = consec +1;
                    if (consec==4)
                    {
                        return true;
                    }
                }
                else if(board[row][col]==0 || board[row][col]==-curPlayer)
                {
                    consec = 0;
                }
            }
            consec = 0; 
        }
        //Check for vertical winner
        consec = 0;
        for (let col=0; col<=6; col++)
        {
            for (let row=0; row<=5; row++)
            {
                if (board[row][col]==curPlayer)
                {
                    consec = consec+1;
                    if (consec==4)
                    {
                        return true;
                    }
                }
                else
                {
                    consec = 0;
                }
            }
        }
        //Check positive slope winner
        for (let row=0; row<3; row++)
        {
            for (let col=0; col<4; col++)
            {
                if (board[row][col]==curPlayer && board[row+1][col+1]==curPlayer && board[row+2][col+2]==curPlayer && board[row+3][col+3]==curPlayer)
                {
                    return true;
                }
            }
         }
        //Check negative slope winner
        for (let row=5; row>2; row--)
        {
            for (let col=0; col<4; col++)
            {
                if (board[row][col]==curPlayer && board[row-1][col+1]==curPlayer && board[row-2][col+2]==curPlayer && board[row-3][col+3]==curPlayer)
                {
                    return true;
                }
            }
         }
        return false;

    }

    function updateBoard(b, player, col){
        //let b=structuredClone(board);
        if (player)
        {
            for (let row=0; row<=5; row++)
                {
                    if (b[row][col] == 0)
                    {
                        //rowIndex = pieceRowLoc[row];
                        rowIndex = row;
                        b[row][col] = player;
                        break;
                    }
                }
        }
        return {b,rowIndex};
    }

    function getRandInt(min, max)
    {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min) + min);
    }

    function sectionsOfFour(brd, curPlayer)
    {   var section = new Array();
        for (var row=0; row <6; row++)
        {
            for (var col=0; col<4; col++)
            {
                section.push([brd[row][col],brd[row][col+1],brd[row][col+2],brd[row][col+3]]);
            }
        }
        for (let col=0; col<7; col++)
        {
            for (let row=0; row<3; row++)
            {
                section.push([brd[row][col],brd[row+1][col],brd[row+2][col],brd[row+3][col]]);
            }
        }
        for (let row=0; row<3; row++)
        {
            for (let col=0; col<4; col++)
            {
                section.push([brd[row][col],brd[row+1][col+1],brd[row+2][col+2],brd[row+3][col+3]]);
            }
        }
        for (let row=5; row>2; row--)
        {
            for (let col=0; col<4; col++)
            {
                section.push([brd[row][col],brd[row-1][col+1],brd[row-2][col+2],brd[row-3][col+3]]);
            }
        }
        return section;
    }

    function sectionScore(section, player)
    {
        var scr = 0;
        var plyrCnt = 0;
        var oppCnt = 0;
        var openPosCnt = 0;
        for (var i=0; i<4; i++)
        {
            if (section[i] == player) plyrCnt +=1;
            else if (section[i]== -player) oppCnt +=1;
            else if (section[i]== 0) openPosCnt +=1;
        }
        if (plyrCnt == 4) scr +=1000;
        if (plyrCnt == 3 && openPosCnt ==1) scr += 5;
        if (plyrCnt ==2 && openPosCnt ==2) scr += 2;
        if (oppCnt == 3 && openPosCnt ==1) scr -= 4;
        
        return scr;
    }

    function getScore(brd, player)
    {
        var scr = 0;
        var sections = sectionsOfFour(brd);
        for (var i=0; i < sections.length; i++)
        {
            scr += sectionScore(sections[i], player);
        }
        for ( var i =0; i<6; i++)
        {
            if (brd[i][3]==player) scr +=3;
        }
        return scr;
    }

    function aiEvalCheck(b, curPlayer)
    {
        var consec = 0;
        var maxConsec = 0;
        var xCoord = 0;
        var yCoord = 0;
        for (let row=0; row<=5; row++)
        {
            for (let col=0; col<=6; col++)
            {
                if (b[row][col]==curPlayer)
                {
                    consec = consec +1;
                    if (consec==4)
                    {
                        return true;
                    }
                }
                else if(b[row][col]==0)
                {
                    
                    if (consec > maxConsec)
                    {
                        maxConsec = consec;
                        xCoord = col;
                        yCoord = row;                     
                        
                    }
                    consec = 0;
                }
                else
                {
                    consec =0;
                }
            }
            consec = 0;
        }
        //Check for vertical winner
        consec = 0;
        for (let col=0; col<=6; col++)
        {
            for (let row=0; row<=5; row++)
            {
                if (b[row][col]==curPlayer)
                {
                    consec = consec+1;
                    if (consec==4)
                    {
                        return true;
                    }
                }
                else if (b[row][col]==0)
                {
                    if (consec > maxConsec)
                        {
                            maxConsec = consec;
                            xCoord = col;
                            yCoord = row;
                        }
                    consec = 0;
                }
                else
                {
                    consec=0;
                }
            }
        }
        
                //Check positive slope winner
        for (let row=0; row<3; row++)
        {
            for (let col=0; col<4; col++)
            {
                if (b[row][col]==curPlayer && b[row+1][col+1]==curPlayer && b[row+2][col+2]==curPlayer && b[row+3][col+3]==curPlayer)
                {
                    return true;
                }
                if (b[row][col]==curPlayer && b[row+1][col+1]==curPlayer && b[row+2][col+2]==curPlayer && b[row+3][col+3]==0)
                {
                    if (maxConsec < 3)
                    {
                        maxConsec = 3;
                        xCoord = col+3;
                        yCoord = row+3;
                    }
                }
                if (b[row][col]==curPlayer && b[row+1][col+1]==curPlayer && b[row+2][col+2]==0)
                {
                    if (maxConsec < 2)
                    {
                        maxConsec = 2;
                        xCoord = col+2;
                        yCoord = row+2;
                    }
                }
            }
         }
        //Check negative slope winner
        for (let row=5; row>2; row--)
        {
            for (let col=0; col<4; col++)
            {
                if (b[row][col]==curPlayer && b[row-1][col+1]==curPlayer && b[row-2][col+2]==curPlayer && b[row-3][col+3]==curPlayer)
                {
                    return true;
                }
                if (b[row][col]==curPlayer && b[row-1][col+1]==curPlayer && b[row-2][col+2]==curPlayer && b[row-3][col+3]==0)
                {
                    if (maxConsec < 3)
                    {
                        maxConsec = 3;
                        xCoord = col+3;
                        yCoord = row-3;
                    }
                }
                if (b[row][col]==curPlayer && b[row-1][col+1]==curPlayer && b[row-2][col+2]==0)
                {
                    if (maxConsec < 2)
                    {
                        maxConsec = 2;
                        xCoord = col+2;
                        yCoord = row-2;
                    }
                }
            }
         }
        return {xCoord, yCoord,maxConsec};
    }
        
    function boardFull(brd)
    {
        for (let i=0; i<7; i++)
        {
            if (brd[5][i]==0) return false;
        }
        return true;
    }
	    
    function getOpenCol(brd)
	    {
		    var openCol = [[],[],[],[],[],[],[]];
		    for (c=0; c<7; c++)
		    {
			    for (r=0; r<6; r++)
			    {
				    if (brd[r][c] == 0)
				    {
					    openCol[c] = [c,r];
                        break;
				    }
				    
			    }
		    }            
			if (openCol.length > 0)
			{
				return openCol;
			}
				    
	    }
        
    function miniMax(brd, player, depth, alpha, beta)
    {
	    var openColumnList = getOpenCol(brd);
        if (evalFunction(brd, -1)==true) return [-1, 9999];
        if (evalFunction(brd, 1)==true) return [-1, -9999];
        if (boardFull(brd)) return [-1, 0];
	    //var playerScore = aiEvalCheck(brd, player).maxConsec * -player;	
        if (depth == 0) return [-1, getScore(brd,-1)];
        
        if (player == -1) 
        {
        // Maximizing player
        var value = Number.NEGATIVE_INFINITY;
        var col = -1;
        for (var i = 0; i < 7; i++) 
        {
            if (board[5][i] == 0) {
                var boardCopy = new Array(6);
                boardCopy = structuredClone(brd);
                var j = 0;
                for (j; j <=4; j++) {
                    if (boardCopy[j][i] == 0)
                        break;
                }
                
                boardCopy[j][i] = player;
                var newScore = miniMax(boardCopy, -player, depth - 1, alpha, beta)[1];
                if (newScore > value) {
                    value = newScore;
                    col = i;
                }
                alpha = Math.max(alpha, value);
                if (alpha >= beta) break;
            }
            
        }
        return [col, value];
    } else 
    {
        // Minimizing player
        var value = Number.POSITIVE_INFINITY;
        var col = -1;
        for (var i = 0; i < 7; i++) 
        {
            if (board[5][i] == 0) {
                var boardCopy = new Array(6);
                boardCopy = structuredClone(brd);
                var j = 0;
                for (j; j <=4; j++) {
                    if (boardCopy[j][i] == 0)
                        break;
                }
                boardCopy[j][i] = player;
                var newScore = miniMax(boardCopy, -player, depth - 1, alpha, beta)[1];
                if (newScore < value) {
                    value = newScore;
                    col = i;
                }
                beta = Math.min(beta, value);
                if (alpha >= beta) break;
            }
            
        }
        return [col, value];
    }
    }

    function aiPlayer(brd)
    {
        let v = miniMax(brd, -1, 3, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);
        let aiPosVal=v[0];
        return aiPosVal;
    }
 
    function update()
    {
        
        if (addPiece)
        {
            if (newPlayerPiece.y < row)
            {
                newPlayerPiece.y = newPlayerPiece.y +20;
            }
            else if (newPlayerPiece.y >= row)
            {

                if(evalFunction(board, player))
                {
                    if (player == 1)
                    {
                        this.text.setText("YOU Win!");
                        player = 999;
                    }
                    else if (player == -1)
                    {
                        this.text.setText("YOU LOSE!");
                        player = 999;
                    }

                    clearBoard(board, player);
                }
                else if (addBlockerPiece)
                {
                    aiBlockerCnt =0;
                    addBlockerPiece = false;
                }
                else
                {
                    player = -player;
                    aiBlockerCnt +=1;
                }
                
                addPiece = false;
            }
        }

        if (this.left.isDown)
        {
            if (this.keyReleased==true)
            {
                for (let i=0; i<=6; i++)
                {
                    if(this.pPosPiece.x == pieceColLoc[i] && i >0)
                    {
                        this.pPosPiece.x = pieceColLoc[i-1];
                        pPieceCol = i-1;
                        break;
                    }
                }
                this.keyReleased = false;
            }
        }
        else if (this.right.isDown)
        {
            if (this.keyReleased==true)
            {
                for (let i=0; i<6; i++){
                    if(this.pPosPiece.x == pieceColLoc[i] && i <6)
                    {
                        this.pPosPiece.x = pieceColLoc[i+1];
                        pPieceCol = i+1;
                        break;
                    }
                }
                this.keyReleased = false;
            }
        }
        else if (this.enter.isDown && player ==1)
        {
            
            if (this.keyReleased==true)
            {
//                for (let i=0; i<=5; i++)
//                {
//                    if (board[i][pPieceCol] == 0)
//                    {
//                        row = pieceRowLoc[i];
//                        board[i][pPieceCol] = player;
//                        break;
//                    }
//                }
                let vals=updateBoard(board, player, pPieceCol);
                board = vals.b;
                row = pieceRowLoc[vals.rowIndex];
                if (player==1)
                {
 
                    newPlayerPiece = pPieces.pop();
                }
                else if (player==-1)
                {

                    newPlayerPiece = aiPieces.pop();
                }
                newPlayerPiece.x = this.pPosPiece.x;

                addPiece = true;
            }
            this.keyReleased = false;
        }
        else if (this.left.isUp && 
                this.right.isUp && 
                this.enter.isUp &&
                !addPiece)
        {
            this.keyReleased = true;
        }

        if (player==-1 && addPiece==false)
        {
            let aiColPos = miniMax(board,player,3,Math.NEGATIVE_INFINITY,Math.POSITIVE_INFINITY)[0];
            let bVals = updateBoard(board,player,aiColPos);
            board = bVals.b;
            newPlayerPiece = aiPieces.pop();
            newPlayerPiece.x = pieceColLoc[aiColPos];
            row = pieceRowLoc[bVals.rowIndex];
            addPiece = true;

        }

        if (aiBlockerCnt==6 && addPiece==false && player == 1)
        {
            let aiColPos = miniMax(board,-player,3,Math.NEGATIVE_INFINITY,Math.POSITIVE_INFINITY)[0];
            let bVals = updateBoard(board,20,aiColPos);
            board = bVals.b;
            newPlayerPiece = aiBlockerPieces.pop();
            newPlayerPiece.x = pieceColLoc[aiColPos];
            row = pieceRowLoc[bVals.rowIndex];
            addBlockerPiece = true;
            addPiece = true;
        }

         
    }
    </script>
    <!--<script type="module" src="./phaser/dist/phaser.js" charset="utf-8"></script>-->
</body>
</html>